package com.puffy.mitigations

import com.puffy.events.DetectionEventEmitter
import com.puffy.events.DetectionInfo
import com.puffy.events.PacketEventEmitter
import kotlin.math.abs
import kotlin.math.sqrt
import net.fabricmc.fabric.api.event.lifecycle.v1.ServerTickEvents
import net.fabricmc.fabric.api.event.lifecycle.v1.ServerTickEvents.EndTick
import net.minecraft.network.packet.c2s.play.PlayerMoveC2SPacket
import net.minecraft.server.network.ServerPlayerEntity

const val SLIDING_WINDOW_LENGTH_TICKS = 20
const val MAXIMUM_AVERAGE_MAGNITUDE = 0.95
const val MAX_FALLING_Y_DIFFERENCE = -0.5
const val MAX_ASCENDING_Y_DIFFERENCE = 0.2
const val MAXIMUM_SUSPICIOUS_MAGNITUDE_TICKS = 25

// Used if minecraft reports a XYZ before the player loads (usually garbage)
const val FALSE_MAGNITUDE_THRESHOLD = 100
private const val MITIGATION_NAME = "Speed"
private const val SERVER_VELOCITY_THRESHOLD = 3

class AntiSpeedMitigation(val player: ServerPlayerEntity) {
    private var movementMagnitudes: MutableList<Double> = mutableListOf()
    private var lastX: Double = 0.0
    private var lastY: Double = 0.0
    private var lastZ: Double = 0.0
    private var suspiciousMagnitudeTicks = 0
    private var firstIteration: Boolean = false

    init {
        PacketEventEmitter.addListener(player, PlayerMoveC2SPacket::class) { _ ->
            if (isSpeedHacking()) {
                DetectionEventEmitter.sendEvent(DetectionInfo(MITIGATION_NAME, player))
            }
        }

        ServerTickEvents.END_SERVER_TICK.register(
            EndTick {
                if (firstIteration) {
                    updateLastPositionWithCurrentPosition()
                    firstIteration = true
                }

                updateMagnitudeWithCurrentPlayerMovement()
                updateLastPositionWithCurrentPosition()
                updateSuspiciousTicksCount()
            }
        )
    }

    private fun isSpeedHacking(): Boolean {
        return suspiciousMagnitudeTicks > MAXIMUM_SUSPICIOUS_MAGNITUDE_TICKS
    }

    private fun updateSuspiciousTicksCount() {
        if (calculateAverageMagnitude() >= MAXIMUM_AVERAGE_MAGNITUDE) {
            suspiciousMagnitudeTicks++
        } else {
            suspiciousMagnitudeTicks = 0
        }
    }

    private fun calculateAverageMagnitude(): Double {
        if (movementMagnitudes.isEmpty()) {
            return 0.0
        }

        return movementMagnitudes.average()
    }

    private fun updateMagnitudeWithCurrentPlayerMovement() {
        val magnitude = calculateMagnitudeForPlayer()
        if (magnitude >= FALSE_MAGNITUDE_THRESHOLD) {
            return
        }

        if (movementMagnitudes.count() >= SLIDING_WINDOW_LENGTH_TICKS) {
            movementMagnitudes.removeAt(0)
        }
        movementMagnitudes.add(magnitude)
    }

    private fun calculateMagnitudeForPlayer(): Double {
        val xDiff = player.x - lastX
        val yDiff = player.y - lastY
        val zDiff = player.z - lastZ

        return sqrt(abs(xDiff) * abs(xDiff) + abs(yDiff) * abs(yDiff) + abs(zDiff) * abs(zDiff)) *
            getPlayerSpecificWeight()
    }

    /**
     * Returns a weight to weight the final magnitude. Allows for normal behaviors to be discarded
     * earlier in the system, such as boat-ice speed and falling
     */
    private fun getPlayerSpecificWeight(): Double {
        var weight = 1.0

        if (player.isFallFlying) {
            weight *= 0.20
        }

        if (player.y - lastY < MAX_FALLING_Y_DIFFERENCE) {
            weight *= 0.55 // Helpful for reducing false positive when falling
        }

        // However, to combat elytra fly + other antics with fall-flight cheats we can *increase*
        // sensitivity when someone is oddly levitating in fall flight.
        if (player.isFallFlying && player.y - lastY > MAX_ASCENDING_Y_DIFFERENCE) {
            weight *= 6
        }

        if (player.isCreative) {
            weight *= 0
        }

        if (player.abilities.flying || player.abilities.allowFlying) {
            // Friction is not considered during flight, so players can accidentally trigger this
            // mitigation.
            weight *= 0.25
        }

        if (player.velocity.length() > SERVER_VELOCITY_THRESHOLD) {
            // Players cannot affect their own velocity, only where they are supposed to move
            weight *= 0.25
        }

        return weight
    }

    private fun updateLastPositionWithCurrentPosition() {
        lastX = player.x
        lastY = player.y
        lastZ = player.z
    }
}
