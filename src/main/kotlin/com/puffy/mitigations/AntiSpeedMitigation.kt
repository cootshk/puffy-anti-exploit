package com.puffy.mitigations

import com.puffy.events.DetectionEventEmitter
import com.puffy.events.DetectionInfo
import com.puffy.events.PacketEventEmitter
import com.puffy.mitigations.antispeed.MagnitudeWeighter
import com.puffy.util.trimToLength
import kotlin.math.abs
import net.fabricmc.fabric.api.event.lifecycle.v1.ServerTickEvents
import net.fabricmc.fabric.api.event.lifecycle.v1.ServerTickEvents.EndTick
import net.minecraft.network.packet.c2s.play.PlayerMoveC2SPacket
import net.minecraft.server.network.ServerPlayerEntity

const val SLIDING_WINDOW_LENGTH_TICKS = 20
const val MAXIMUM_AVERAGE_MAGNITUDE = 0.95
const val MAXIMUM_SUSPICIOUS_MAGNITUDE_TICKS = 25

// Used if minecraft reports a XYZ before the player loads (usually garbage)
const val FALSE_MAGNITUDE_THRESHOLD = 100
private const val MITIGATION_NAME = "Speed"

class AntiSpeedMitigation(val player: ServerPlayerEntity) {
    private var magnitudeWindow: MutableList<Double> = mutableListOf()
    private val averageMagnitude: Double
        get() = magnitudeWindow.average()

    private var lastX: Double = 0.0
    private var lastY: Double = 0.0
    private var lastZ: Double = 0.0
    private var suspiciousMagnitudeTicks = 0
    private var firstIteration: Boolean = false

    init {
        PacketEventEmitter.addListener(player, PlayerMoveC2SPacket::class) { _ ->
            if (isSpeedHacking()) {
                DetectionEventEmitter.sendEvent(DetectionInfo(MITIGATION_NAME, player))
            }
        }

        ServerTickEvents.END_SERVER_TICK.register(
            EndTick {
                if (firstIteration) {
                    updateLastPositionWithCurrentPosition()
                    firstIteration = true
                }

                addCurrentMagnitudeToWindow()
                updateLastPositionWithCurrentPosition()
                updateSuspiciousTicksCount()
            }
        )
    }

    private fun isSpeedHacking(): Boolean =
        suspiciousMagnitudeTicks > MAXIMUM_SUSPICIOUS_MAGNITUDE_TICKS

    private fun updateSuspiciousTicksCount() {
        if (!averageMagnitude.isNaN() && averageMagnitude >= MAXIMUM_AVERAGE_MAGNITUDE) {
            suspiciousMagnitudeTicks++
        } else {
            suspiciousMagnitudeTicks = 0
        }
    }

    private fun addCurrentMagnitudeToWindow() {
        val magnitude = calculateMagnitudeForPlayer()
        if (magnitude >= FALSE_MAGNITUDE_THRESHOLD) {
            return
        }

        magnitudeWindow.trimToLength(SLIDING_WINDOW_LENGTH_TICKS)
        magnitudeWindow.add(magnitude)
    }

    private fun calculateMagnitudeForPlayer(): Double {
        val xDiff = player.x - lastX
        val yDiff = player.y - lastY
        val zDiff = player.z - lastZ

        val magnitude = abs(xDiff) * abs(xDiff) + abs(yDiff) * abs(yDiff) + abs(zDiff) * abs(zDiff)
        return MagnitudeWeighter.getWeightedMagnitude(magnitude, player, lastY)
    }

    private fun updateLastPositionWithCurrentPosition() {
        lastX = player.x
        lastY = player.y
        lastZ = player.z
    }
}
