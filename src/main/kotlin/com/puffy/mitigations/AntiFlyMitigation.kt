package com.puffy.mitigations

import com.puffy.events.PacketEventEmitter
import com.puffy.util.disconnectForExploit
import net.fabricmc.fabric.api.event.lifecycle.v1.ServerTickEvents
import net.fabricmc.fabric.api.event.lifecycle.v1.ServerTickEvents.EndTick
import net.minecraft.network.packet.c2s.play.PlayerMoveC2SPacket
import net.minecraft.server.network.ServerPlayerEntity

const val MAXIMUM_TICKS_SPENT_FLOATING = 85
const val MAXIMUM_TICKS_SPENT_ASCENDING = 20
private const val MITIGATION_NAME = "Flight"

class AntiFlyMitigation(val player: ServerPlayerEntity) {
    private var ticksSpentFloating = 0
    private var ticksSpentAscending = 0
    private var lastY = 0.0

    private var isAllowedToFly = false

    init {
        PacketEventEmitter.addListener(player, PlayerMoveC2SPacket::class) { _ ->
            if (isFlyHacking()) {
                player.disconnectForExploit(MITIGATION_NAME)
            }
        }

        ServerTickEvents.END_SERVER_TICK.register(
            EndTick {
                updateTicksFloating()
                updateTicksAscending()
                resetCountersWhenFlightRemoved()
                isAllowedToFly = isFlightAllowedAtCurrentTick()
            }
        )
    }

    private fun isFlyHacking(): Boolean {
        return (ticksSpentFloating >= MAXIMUM_TICKS_SPENT_FLOATING ||
            ticksSpentAscending >= MAXIMUM_TICKS_SPENT_ASCENDING) && !isAllowedToFly
    }

    private fun updateTicksFloating() {
        val world = player.entityWorld
        val boundingBox = player.boundingBox.expand(0.0, 0.2, 0.0)

        val collidingBlocks = world.getBlockCollisions(player, boundingBox)
        val collidingEntities =
            world.getOtherEntities(player, boundingBox) { entity -> !entity.equals(player) }

        if (!collidingBlocks.any() && !collidingEntities.any()) {
            ticksSpentFloating++
        } else {
            ticksSpentFloating = 0
        }
    }

    private fun updateTicksAscending() {
        if (player.y > lastY) {
            ticksSpentAscending++
        } else {
            ticksSpentAscending = 0
        }

        lastY = player.y
    }

    private fun isFlightAllowedAtCurrentTick(): Boolean {
        return (player.abilities.flying || player.abilities.allowFlying) ||
            player.isTouchingWater ||
            player.isSubmergedInWater ||
            player.isSwimming ||
            player.isFallFlying
    }

    private fun resetCountersWhenFlightRemoved() {
        if (isAllowedToFly != isFlightAllowedAtCurrentTick()) {
            ticksSpentFloating = 0
            ticksSpentAscending = 0
        }
    }
}
