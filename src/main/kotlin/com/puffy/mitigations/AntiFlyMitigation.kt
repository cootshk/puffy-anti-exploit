package com.puffy.mitigations

import com.puffy.events.DetectionEventEmitter
import com.puffy.events.DetectionInfo
import com.puffy.events.PacketEventEmitter
import com.puffy.util.isAllowedFlight
import com.puffy.util.isInAir
import net.fabricmc.fabric.api.event.lifecycle.v1.ServerTickEvents
import net.fabricmc.fabric.api.event.lifecycle.v1.ServerTickEvents.EndTick
import net.minecraft.network.packet.c2s.play.PlayerMoveC2SPacket
import net.minecraft.server.network.ServerPlayerEntity

const val MAXIMUM_TICKS_SPENT_FLOATING = 85
const val MAXIMUM_TICKS_SPENT_ASCENDING = 20
private const val FLOATING_Y_TOLERANCE = 1
private const val MITIGATION_NAME = "Flight"

class AntiFlyMitigation(val player: ServerPlayerEntity) {
    private var ticksSpentFloating = 0
    private var ticksSpentAscending = 0
    private var lastY = 0.0

    private var lastTickFlightPermission = false

    init {
        PacketEventEmitter.addListener(player, PlayerMoveC2SPacket::class) { _ ->
            if (isFlyHacking()) {
                DetectionEventEmitter.sendEvent(DetectionInfo(MITIGATION_NAME, player))
            }
        }

        ServerTickEvents.END_SERVER_TICK.register(
            EndTick {
                updateTicksFloating()
                updateTicksAscending()
                resetCountersWhenFlightRemoved()
                lastTickFlightPermission = player.isAllowedFlight()
            }
        )
    }

    private fun isFlyHacking(): Boolean {
        return (ticksSpentFloating >= MAXIMUM_TICKS_SPENT_FLOATING ||
            ticksSpentAscending >= MAXIMUM_TICKS_SPENT_ASCENDING) && !player.isAllowedFlight()
    }

    private fun updateTicksFloating() {
        if (player.isInAir() && player.y - lastY <= FLOATING_Y_TOLERANCE) {
            ticksSpentFloating++
        } else {
            ticksSpentFloating = 0
        }
    }

    private fun updateTicksAscending() {
        if (player.y > lastY && !player.isAllowedFlight()) {
            ticksSpentAscending++
        } else {
            ticksSpentAscending = 0
        }

        lastY = player.y
    }

    private fun resetCountersWhenFlightRemoved() {
        if (lastTickFlightPermission != player.isAllowedFlight()) {
            ticksSpentFloating = 0
            ticksSpentAscending = 0
        }
    }
}
