package com.puffy.mitigations

import com.puffy.events.PacketEventEmitter
import com.puffy.util.disconnectForExploit
import net.fabricmc.fabric.api.event.lifecycle.v1.ServerTickEvents
import net.fabricmc.fabric.api.event.lifecycle.v1.ServerTickEvents.EndTick
import net.minecraft.entity.effect.StatusEffect
import net.minecraft.network.packet.c2s.play.PlayerMoveC2SPacket
import net.minecraft.server.network.ServerPlayerEntity

const val MAXIMUM_TICKS_SPENT_FLOATING = 85
const val MAXIMUM_TICKS_SPENT_ASCENDING = 20
private const val FLOATING_Y_TOLERANCE = 1
private const val MITIGATION_NAME = "Flight"
// https://minecraft.fandom.com/wiki/Levitation
private const val LEVITATION_STATUS_ID = 25
// Likely, once the player's velocity reaches this threshold it's probably from a tnt jump or mod
private const val FLIGHT_SPEED_THRESHOLD = 5

class AntiFlyMitigation(val player: ServerPlayerEntity) {
    private var ticksSpentFloating = 0
    private var ticksSpentAscending = 0
    private var lastY = 0.0

    private var isAllowedToFly = false

    init {
        PacketEventEmitter.addListener(player, PlayerMoveC2SPacket::class) { _ ->
            if (isFlyHacking()) {
                player.disconnectForExploit(MITIGATION_NAME)
            }
        }

        ServerTickEvents.END_SERVER_TICK.register(
            EndTick {
                updateTicksFloating()
                updateTicksAscending()
                resetCountersWhenFlightRemoved()
                isAllowedToFly = isFlightAllowedAtCurrentTick()
            }
        )
    }

    private fun isFlyHacking(): Boolean {
        return (ticksSpentFloating >= MAXIMUM_TICKS_SPENT_FLOATING ||
            ticksSpentAscending >= MAXIMUM_TICKS_SPENT_ASCENDING) && !isAllowedToFly
    }

    private fun updateTicksFloating() {
        val world = player.entityWorld
        val boundingBox = player.boundingBox.expand(0.0, 0.2, 0.0)

        val collidingBlocks = world.getBlockCollisions(player, boundingBox)
        val collidingEntities =
            world.getOtherEntities(player, boundingBox) { entity -> !entity.equals(player) }

        if (
            !collidingBlocks.any() &&
                !collidingEntities.any() &&
                player.y - lastY <= FLOATING_Y_TOLERANCE
        ) {
            ticksSpentFloating++
        } else {
            ticksSpentFloating = 0
        }
    }

    private fun updateTicksAscending() {
        if (player.y > lastY && !isFlightAllowedAtCurrentTick()) {
            ticksSpentAscending++
        } else {
            ticksSpentAscending = 0
        }

        lastY = player.y
    }

    private fun isFlightAllowedAtCurrentTick(): Boolean {
        return (player.abilities.flying || player.abilities.allowFlying) ||
            player.isTouchingWater ||
            player.isSubmergedInWater ||
            player.isSwimming ||
            player.isFallFlying ||
            player.hasStatusEffect(StatusEffect.byRawId(LEVITATION_STATUS_ID)) ||
            player.velocity.length() >= FLIGHT_SPEED_THRESHOLD ||
            player.fallDistance > 0
    }

    private fun resetCountersWhenFlightRemoved() {
        if (isAllowedToFly != isFlightAllowedAtCurrentTick()) {
            ticksSpentFloating = 0
            ticksSpentAscending = 0
        }
    }
}
