package com.puffy.mitigations

import com.puffy.events.DetectionEventEmitter
import com.puffy.events.DetectionInfo
import com.puffy.events.PacketEventEmitter
import com.puffy.util.isAttack
import kotlin.math.abs
import kotlin.math.acos
import net.fabricmc.fabric.api.event.lifecycle.v1.ServerTickEvents
import net.fabricmc.fabric.api.event.lifecycle.v1.ServerTickEvents.EndTick
import net.minecraft.entity.Entity
import net.minecraft.network.packet.c2s.play.PlayerInteractEntityC2SPacket
import net.minecraft.server.network.ServerPlayerEntity

const val MAXIMUM_SUSPICIOUS_HITS_IN_PERIOD = 6
const val PERIOD_TIME_IN_TICKS = 150
const val AIM_DEGREE_TOLERANCE = 45

const val MAXIMUM_DISTANCE_METERS = 6
private const val MITIGATION_NAME = "KillAura"

class AntiKillAuraMitigation(val player: ServerPlayerEntity) {
    private var suspiciousHitCountInPeriod = 0
    private var periodTickCounter = 0

    init {
        PacketEventEmitter.addListener(player, PlayerInteractEntityC2SPacket::class) { (_, packet)
            ->
            if (!packet.isAttack()) {
                return@addListener
            }

            val targetEntity = packet.getEntity(player.serverWorld) ?: return@addListener
            recordHitIfSuspicious(targetEntity)

            if (suspiciousHitCountInPeriod >= MAXIMUM_SUSPICIOUS_HITS_IN_PERIOD) {
                DetectionEventEmitter.sendEvent(DetectionInfo(MITIGATION_NAME, player))
            }
        }

        ServerTickEvents.END_SERVER_TICK.register(
            EndTick {
                periodTickCounter++

                if (periodTickCounter >= PERIOD_TIME_IN_TICKS) {
                    suspiciousHitCountInPeriod = 0
                    periodTickCounter = 0
                }
            }
        )
    }

    private fun recordHitIfSuspicious(targetEntity: Entity) {
        if (isHitSuspicious(targetEntity)) {
            suspiciousHitCountInPeriod++
        }
    }

    private fun isHitSuspicious(targetEntity: Entity): Boolean {
        if (!targetEntity.isAlive()) {
            return false
        }

        val playerEye = player.getCameraPosVec(0.0F)
        val playerLookVector = player.cameraEntity.getRotationVec(0.0F)
        val directionTowardsEntity = targetEntity.boundingBox.center.subtract(playerEye).normalize()
        val angleOfError = Math.toDegrees(acos(playerLookVector.dotProduct(directionTowardsEntity)))

        val distanceBetweenPlayerAndTarget = targetEntity.pos.squaredDistanceTo(player.pos)
        return abs(angleOfError) > AIM_DEGREE_TOLERANCE ||
            distanceBetweenPlayerAndTarget > MAXIMUM_DISTANCE_METERS * MAXIMUM_DISTANCE_METERS ||
            isTargetBehindWallFromPlayer(player, targetEntity)
    }

    private fun isTargetBehindWallFromPlayer(
        player: ServerPlayerEntity,
        targetEntity: Entity
    ): Boolean {
        return false // TODO: Make a way to do this well
    }
}
