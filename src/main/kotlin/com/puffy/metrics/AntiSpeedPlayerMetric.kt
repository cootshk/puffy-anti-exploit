package com.puffy.metrics

import net.minecraft.network.packet.Packet
import net.minecraft.server.MinecraftServer
import net.minecraft.server.network.ServerPlayerEntity
import org.slf4j.LoggerFactory
import kotlin.math.abs
import kotlin.math.sqrt

const val SLIDING_WINDOW_LENGTH_TICKS = 20
const val MAXIMUM_AVERAGE_MAGNITUDE = 0.95
const val MAX_FALLING_Y_DIFFERENCE = -0.5
const val MAX_ASCENDING_Y_DIFFERENCE = 0.2
const val MAXIMUM_SUSPICIOUS_MAGNITUDE_TICKS = 25

// Used if minecraft reports a XYZ before the player loads (usually garbage)
const val FALSE_MAGNITUDE_THRESHOLD = 100

class AntiSpeedPlayerMetric : PlayerMetric {
    private var movementMagnitudes: MutableList<Double> = mutableListOf()
    private var lastX: Double = 0.0
    private var lastY: Double = 0.0
    private var lastZ: Double = 0.0
    private var suspiciousMagnitudeTicks = 0
    private var firstIteration: Boolean = false

    override fun isPlayerSuspicious(): Boolean {
        return suspiciousMagnitudeTicks > MAXIMUM_SUSPICIOUS_MAGNITUDE_TICKS
    }

    private fun calculateAverageMagnitude(): Double {
        if (movementMagnitudes.isEmpty()) {
            return 0.0
        }

        return movementMagnitudes.reduce { acc, magnitude -> acc + magnitude } / movementMagnitudes.count()
    }

    override fun inspectIncomingPacketData(packet: Packet<*>, player: ServerPlayerEntity) = Unit

    override fun updateMetric(player: ServerPlayerEntity, server: MinecraftServer) {
        if (firstIteration) {
            updateLastPositionWithCurrentPosition(player)
            firstIteration = true
        }

        updateMagnitudeWithCurrentPlayerMovement(player)
        updateLastPositionWithCurrentPosition(player)
        updateSuspiciousTicksCount()
    }

    private fun updateSuspiciousTicksCount() {
        if (calculateAverageMagnitude() >= MAXIMUM_AVERAGE_MAGNITUDE) {
            suspiciousMagnitudeTicks++
        } else {
            suspiciousMagnitudeTicks = 0
        }
    }

    private fun updateMagnitudeWithCurrentPlayerMovement(player: ServerPlayerEntity) {
        val magnitude = calculateMagnitudeForPlayer(player)
        if (magnitude >= FALSE_MAGNITUDE_THRESHOLD) {
            return
        }

        if (movementMagnitudes.count() >= SLIDING_WINDOW_LENGTH_TICKS) {
            movementMagnitudes.removeFirst()
        }
        movementMagnitudes.add(magnitude)
    }

    private fun calculateMagnitudeForPlayer(player: ServerPlayerEntity): Double {
        val xDiff = player.x - lastX
        val yDiff = player.y - lastY
        val zDiff = player.z - lastZ

        return sqrt(abs(xDiff) * abs(xDiff) + abs(yDiff) * abs(yDiff) + abs(zDiff) * abs(zDiff)) * getPlayerSpecificWeight(player)
    }

    /**
     * Returns a weight to weight the final magnitude. Allows for normal behaviors to be discarded earlier in the system, such as boat-ice speed and falling
     */
    private fun getPlayerSpecificWeight(player: ServerPlayerEntity): Double {
        var weight = 1.0

        if (player.isFallFlying) {
            weight *= 0.20
        }

        if (player.y - lastY < MAX_FALLING_Y_DIFFERENCE) {
            weight *= 0.55 // Helpful for reducing false positive when falling
        }

        // However, to combat elytra fly + other antics with fall-flight cheats we can *increase* sensitivity when someone is oddly levitating in fall flight.
        if (player.isFallFlying && player.y - lastY > MAX_ASCENDING_Y_DIFFERENCE) {
            weight *= 6
        }

        if (player.isCreative) {
            weight *= 0
        }

        return weight
    }

    private fun updateLastPositionWithCurrentPosition(player: ServerPlayerEntity) {
        lastX = player.x
        lastY = player.y
        lastZ = player.z
    }
}