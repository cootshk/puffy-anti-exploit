package com.puffy.metrics

import net.minecraft.network.packet.Packet
import net.minecraft.server.MinecraftServer
import net.minecraft.server.network.ServerPlayerEntity
import org.slf4j.LoggerFactory

// Floating can indicate flight on the X-Z plane, while ascension can indicate a sort of desperate plea for height. Players aren't regularly
// ascending for more than 170 ticks, not even for TnT cannons.
const val MAXIMUM_TICKS_SPENT_FLOATING = 85
const val MAXIMUM_TICKS_SPENT_ASCENDING = 20

class AntiFlyPlayerMetric : PlayerMetric {
    private var ticksSpentFloating = 0;
    private var ticksSpentAscending = 0;

    private var lastY: Double = 0.0;
    private var hasFlyingCapabilities = false;
    private var isPotentiallyInterfering = false;

    override fun isPlayerSuspicious(): Boolean = (ticksSpentFloating > MAXIMUM_TICKS_SPENT_FLOATING || ticksSpentAscending > MAXIMUM_TICKS_SPENT_ASCENDING) && (!hasFlyingCapabilities && !isPotentiallyInterfering)
    override fun inspectIncomingPacketData(packet: Packet<*>, player: ServerPlayerEntity) = Unit

    override fun updateMetric(player: ServerPlayerEntity, server: MinecraftServer) {
        updateTicksAscending(player, server)
        updateTicksFloating(player, server)
        resetCountersIfNoLongerSwimming(player)

        // "Fall-flying" is the internal term for elytra flight
        hasFlyingCapabilities = player.abilities.flying || player.abilities.allowFlying || player.isFallFlying
        isPotentiallyInterfering = checkIfPlayerMightFalselyTriggerFloatingCheck(player)
    }

    private fun checkIfPlayerMightFalselyTriggerFloatingCheck(player: ServerPlayerEntity): Boolean {
        return player.isTouchingWater || player.isSwimming || player.isSubmergedInWater || player.isClimbing
    }

    private fun updateTicksFloating(player: ServerPlayerEntity, server: MinecraftServer) {
        val worldPlayerIsIn = player.entityWorld
        val boundingBox = player.boundingBox.expand(0.0, 0.2, 0.0)

        val collidingBlocks = worldPlayerIsIn.getBlockCollisions(player, boundingBox)
        val collidingEntities = worldPlayerIsIn.getOtherEntities(player, boundingBox) { entity -> !entity.equals(player) }

        if (!collidingBlocks.any() && !collidingEntities.any()) {
            ticksSpentFloating++;
        } else {
            ticksSpentFloating = 0;
        }
    }

    private fun updateTicksAscending(player: ServerPlayerEntity, server: MinecraftServer) {
        if (player.y > lastY) {
            ticksSpentAscending++;
        } else {
            ticksSpentAscending = 0;
        }

        lastY = player.y
    }

    private fun resetCountersIfNoLongerSwimming(player: ServerPlayerEntity) {
        if (checkIfPlayerMightFalselyTriggerFloatingCheck(player) != isPotentiallyInterfering) {
            ticksSpentAscending = 0
            ticksSpentFloating = 0
        }
    }
}